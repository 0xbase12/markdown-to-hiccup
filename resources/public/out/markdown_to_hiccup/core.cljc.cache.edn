{:rename-macros {}, :renames {}, :externs {Error {}}, :use-macros {as-hiccup hickory.core, parse hickory.core}, :excludes #{}, :name markdown-to-hiccup.core, :imports nil, :requires {str clojure.string, clojure.string clojure.string, gstr goog.string, goog.string goog.string, r cljs.reader, cljs.reader cljs.reader, hickory.core hickory.core, markdown.core markdown.core}, :cljs.spec/speced-vars [], :uses {md->html markdown.core, as-hiccup hickory.core, parse hickory.core}, :defs {num-partition {:protocol-inline nil, :meta {:file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :line 84, :column 8, :end-line 84, :end-column 21, :private true, :arglists (quote ([args])), :doc "Accepts a list of keywords and numbers. Any place in which\n  a number does not separate keywords, a zero will be inserted.\n  Returns the arg list as a sequence of keyword -> number pairs\n  nested as lists."}, :private true, :name markdown-to-hiccup.core/num-partition, :variadic false, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 21, :method-params ([args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 84, :end-line 84, :max-fixed-arity 1, :fn-var true, :arglists (quote ([args])), :doc "Accepts a list of keywords and numbers. Any place in which\n  a number does not separate keywords, a zero will be inserted.\n  Returns the arg list as a sequence of keyword -> number pairs\n  nested as lists."}, DomNode {:num-fields 1, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name markdown-to-hiccup.core/DomNode, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 19, :type true, :column 12, :internal-ctor true, :line 22, :record true, :end-line 22, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, map->DomNode {:protocol-inline nil, :meta {:file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :line 22, :column 12, :end-line 22, :end-column 19, :internal-ctor true, :factory :map, :arglists (quote ([G__35195]))}, :name markdown-to-hiccup.core/map->DomNode, :variadic false, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 19, :method-params ([G__35195]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 22, :end-line 22, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__35195]))}, ->DomNode {:protocol-inline nil, :meta {:file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :line 22, :column 12, :end-line 22, :end-column 19, :internal-ctor true, :factory :positional, :arglists (quote ([node]))}, :name markdown-to-hiccup.core/->DomNode, :variadic false, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 19, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 22, :end-line 22, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, decode {:protocol-inline nil, :meta {:file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :line 10, :column 7, :end-line 10, :end-column 13, :arglists (quote ([s]))}, :name markdown-to-hiccup.core/decode, :variadic false, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 13, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10, :end-line 10, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, keywords? {:protocol-inline nil, :meta {:file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :line 67, :column 8, :end-line 67, :end-column 17, :private true, :arglists (quote ([& args])), :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}}, :private true, :name markdown-to-hiccup.core/keywords?, :variadic true, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}, :method-params [(args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 67, :end-line 67, :max-fixed-arity 0, :fn-var true, :arglists ([& args])}, same-length? {:protocol-inline nil, :meta {:file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :line 108, :column 8, :end-line 108, :end-column 20, :private true, :arglists (quote ([coll-a coll-b]))}, :private true, :name markdown-to-hiccup.core/same-length?, :variadic false, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 20, :method-params ([coll-a coll-b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 108, :end-line 108, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll-a coll-b]))}, dec-front {:protocol-inline nil, :meta {:file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :line 71, :column 8, :end-line 71, :end-column 17, :private true, :arglists (quote ([kw-pairs])), :doc "Accepts a list of [keyword count] pairs, and subtracts the count\n   of the first pair. If that count becomes negative, dec-front returns\n   the rest of the list. Otherwise, it returns the list with the new\n   count value for the first pair."}, :private true, :name markdown-to-hiccup.core/dec-front, :variadic false, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 17, :method-params ([kw-pairs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 71, :end-line 71, :max-fixed-arity 1, :fn-var true, :arglists (quote ([kw-pairs])), :doc "Accepts a list of [keyword count] pairs, and subtracts the count\n   of the first pair. If that count becomes negative, dec-front returns\n   the rest of the list. Otherwise, it returns the list with the new\n   count value for the first pair."}, md->hiccup {:protocol-inline nil, :meta {:file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :line 32, :column 7, :end-line 32, :end-column 17, :arglists (quote ([md-str params] [md-str])), :doc "Accepts a markdown string and returns a hiccup data structure converted from that markdown.\n  Also accepts an optional params map. Use the :encode? boolean key to specify whether\n  or not you want html escape characters to be encoded. Example:\n    (md->hiccup \"#Title\" {:encode? true})", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([md-str params] [md-str]), :arglists ([md-str params] [md-str]), :arglists-meta (nil nil)}}, :name markdown-to-hiccup.core/md->hiccup, :variadic false, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([md-str params] [md-str]), :arglists ([md-str params] [md-str]), :arglists-meta (nil nil)}, :method-params ([md-str params] [md-str]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 32, :end-line 32, :max-fixed-arity 2, :fn-var true, :arglists ([md-str params] [md-str]), :doc "Accepts a markdown string and returns a hiccup data structure converted from that markdown.\n  Also accepts an optional params map. Use the :encode? boolean key to specify whether\n  or not you want html escape characters to be encoded. Example:\n    (md->hiccup \"#Title\" {:encode? true})"}, hiccup-in {:protocol-inline nil, :meta {:file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :line 138, :column 7, :end-line 138, :end-column 16, :arglists (quote ([hiccup & kw-pairs])), :doc "Accepts a hiccup data structure and any series of args in keyword, index order.\n   Each keyword represents a hiccup element, and the paired index is which element at that level hiccup-in will look in.\n   If no number proceeds a keyword, hiccup-in will find the first element with that keyword.\n   Returns the nested hiccup vector identified by the keywords.\n   Example: (hiccup-in hiccup :html :body :div 0 :h1 2 :p)", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(hiccup kw-pairs)], :arglists ([hiccup & kw-pairs]), :arglists-meta (nil)}}, :name markdown-to-hiccup.core/hiccup-in, :variadic true, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(hiccup kw-pairs)], :arglists ([hiccup & kw-pairs]), :arglists-meta (nil)}, :method-params [(hiccup kw-pairs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 138, :end-line 138, :max-fixed-arity 1, :fn-var true, :arglists ([hiccup & kw-pairs]), :doc "Accepts a hiccup data structure and any series of args in keyword, index order.\n   Each keyword represents a hiccup element, and the paired index is which element at that level hiccup-in will look in.\n   If no number proceeds a keyword, hiccup-in will find the first element with that keyword.\n   Returns the nested hiccup vector identified by the keywords.\n   Example: (hiccup-in hiccup :html :body :div 0 :h1 2 :p)"}, component {:protocol-inline nil, :meta {:file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :line 148, :column 7, :end-line 148, :end-column 16, :arglists (quote ([hiccup])), :doc "Accepts hiccup and returns the same hiccup only\n   without the :html, :head, and :body elements. Useful\n   if you want to nest your markdown hiccup in existing\n   hiccup data structures."}, :name markdown-to-hiccup.core/component, :variadic false, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 16, :method-params ([hiccup]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 148, :end-line 148, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hiccup])), :doc "Accepts hiccup and returns the same hiccup only\n   without the :html, :head, and :body elements. Useful\n   if you want to nest your markdown hiccup in existing\n   hiccup data structures."}, replacer {:protocol-inline nil, :meta {:file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :line 18, :column 7, :end-line 18, :end-column 15, :arglists (quote ([text state]))}, :name markdown-to-hiccup.core/replacer, :variadic false, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 15, :method-params ([text state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 18, :end-line 18, :max-fixed-arity 2, :fn-var true, :arglists (quote ([text state]))}, foo {:protocol-inline nil, :meta {:file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :line 24, :column 7, :end-line 24, :end-column 10, :arglists (quote ([md-str]))}, :name markdown-to-hiccup.core/foo, :variadic false, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 10, :method-params ([md-str]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 24, :end-line 24, :max-fixed-arity 1, :fn-var true, :arglists (quote ([md-str]))}, hicc-in {:protocol-inline nil, :meta {:file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :line 48, :column 7, :end-line 48, :end-column 14, :arglists (quote ([hiccup & kws])), :doc "NOTE: please use hiccup-in for better access to nested hiccup.\n  Accepts a hiccup data structure and a keyword representing\n  an html element tag (e.g. :body) and returns the first nested\n  hiccup vector identified by the keyword.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(hiccup kws)], :arglists ([hiccup & kws]), :arglists-meta (nil)}}, :name markdown-to-hiccup.core/hicc-in, :variadic true, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(hiccup kws)], :arglists ([hiccup & kws]), :arglists-meta (nil)}, :method-params [(hiccup kws)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 48, :end-line 48, :max-fixed-arity 1, :fn-var true, :arglists ([hiccup & kws]), :doc "NOTE: please use hiccup-in for better access to nested hiccup.\n  Accepts a hiccup data structure and a keyword representing\n  an html element tag (e.g. :body) and returns the first nested\n  hiccup vector identified by the keyword."}, get-nested-hiccup {:protocol-inline nil, :meta {:file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :line 113, :column 8, :end-line 113, :end-column 25, :private true, :arglists (quote ([hiccup kw-pairs])), :doc "Recursive helper function for hiccup-in."}, :private true, :name markdown-to-hiccup.core/get-nested-hiccup, :variadic false, :file "/Users/mpcarolin/Source/markdown-to-hiccup/src/markdown_to_hiccup/core.cljc", :end-column 25, :method-params ([hiccup kw-pairs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 113, :end-line 113, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hiccup kw-pairs])), :doc "Recursive helper function for hiccup-in."}}, :cljs.spec/registry-ref [], :require-macros {r cljs.reader, cljs.reader cljs.reader}, :cljs.analyzer/constants {:seen #{:else :encode? :node :div node :body}, :order [:node node :encode? :else :body :div]}, :doc nil}